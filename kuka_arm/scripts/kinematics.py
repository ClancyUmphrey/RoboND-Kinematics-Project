# File: kinematics.py

# Line width: 90

# Author: Clancy Umphrey

# Description:
"""
Kuka KR210 robotic arm module that generates lambda functions for evaluating the end
effector position (eval_ee) given six joint angles, the wrist center position (eval_w)
given an end effector pose, and the six joint angles (eval_theta) given an end effector 
pose.

The necessary symbolic equations are loaded from a pickle file if they have already been
generated by a previous run of the module, otherwise they are calculated and saved to a
pickle file for next time.  Then from the symbolic equations, lambda functions that can
be imported by consumers of this module are generated in order to provide significantly
reduce evaluation time compared to using evalf from sympy.
"""

# Import Modules
#-----------------------------------------------------------------------------------------
from sympy import symbols, cos, sin, atan2, acos, pi, sqrt, simplify, zeros, eye, lambdify
from sympy.matrices import Matrix
from six.moves import cPickle as pickle
import os
import numpy as np
from subprocess import check_output


##########################################################################################
# Setup
##########################################################################################

# Control Flags
#-----------------------------------------------------------------------------------------
FORCE    = False # True: force calculation of kinematics rather than read from pickle.
SIMPLIFY = False # True: simplify the final symbolic equations (adds ~1 min to wall-time).
DEBUG    = False # True: print final symbolic equations.

# Setup Pickle File Path 
#-----------------------------------------------------------------------------------------
try: # to put the pickle file in the directory above kuka_arm
    kuka_arm_dir = os.path.dirname(check_output('rospack find kuka_arm', shell=True))
except: # put the pickle file in the directory where rosrun is executed
    kuka_arm_dir = ''

pickle_file   = os.path.join(kuka_arm_dir, 'kinematics.pickle')
pickle_exists = os.path.exists(pickle_file)


##########################################################################################
# Define Symbols
##########################################################################################

# Symbols for Joint Variables
#-----------------------------------------------------------------------------------------
A0, A1, A2, A3, A4, A5, A6 = symbols('A0:7') # twist angle, Zi-1 to Zi about Xi-1
a0, a1, a2, a3, a4, a5, a6 = symbols('a0:7') # link length, Zi-1 to Zi along Xi-1
d1, d2, d3, d4, d5, d6, d7 = symbols('d1:8') # link offset, Xi-1 to Xi along Zi
q1, q2, q3, q4, q5, q6, q7 = symbols('q1:8') # joint angle, Xi-1 to Xi about Zi

# DH Parameters 
#-----------------------------------------------------------------------------------------
dh = {A0:     0,  a0:      0,  d1:  0.75,
      A1: -pi/2,  a1:   0.35,  d2:     0,  q2: q2-pi/2,
      A2:     0,  a2:   1.25,  d3:     0,
      A3: -pi/2,  a3: -0.054,  d4:  1.50,
      A4:  pi/2,  a4:      0,  d5:     0,
      A5: -pi/2,  a5:      0,  d6:     0,
      A6:     0,  a6:      0,  d7: 0.303,  q7:       0,}

# Symbols for IK
#-----------------------------------------------------------------------------------------
r , p , y  = symbols(( 'r',  'p',  'y')) # roll, pitch, and yaw of end effector (ee)
px, py, pz = symbols(('px', 'py', 'pz')) # x, y, and z position of ee
    

##########################################################################################
# Functions
##########################################################################################

#=====================================================================================
# Helper Functions
#=====================================================================================

c, s = cos, sin

def maybe_simplify(expression):
    """
    Switch simplification on and off using the SIMPLIFY flag.  Turning SIMPLIFY on can
    add on the order of minutes for the kinematics() function to complete.
    """
    if SIMPLIFY: return simplify(expression)
    else       : return expression

def R2T(R, r=zeros(3,1)):
    """
    Given a rotation matrix R, return a homogeneous transformation matrix with a
    reference frame offset of r (defaults to zero vector).
    """
    return R.row_join(r).col_join(eye(4)[-1,:])

def getRfrom(T):
    """
    Extract the rotation matrix from the given transformation matrix T.
    """
    return T[0:3, 0:3]

def R_x(q):
    """
    Rotation matrix about the x-axis given angle q.
    """
    Rx = Matrix([[      1,     0,     0],
                 [      0,  c(q), -s(q)],
                 [      0,  s(q),  c(q)]])
    return Rx

def R_y(q):
    """
    Rotation matrix about the y-axis given angle q.
    """
    Ry = Matrix([[ c(q),       0,  s(q)],
                 [    0,       1,     0],
                 [-s(q),       0,  c(q)]])
    return Ry

def R_z(q):
    """
    Rotation matrix about the z-axis given angle q.
    """
    Rz = Matrix([[ c(q), -s(q),       0],
                 [ s(q),  c(q),       0],
                 [    0,     0,       1]])
    return Rz

def Transform(A, a, d, q, subSyms={}):
    """
    Homogeneous transform between links in the Denavit-Hartenberg (DH) convention with
    symbol substitution.
    """
    Tsub = Matrix([[      c(q),     -s(q),     0,       a],
                   [ s(q)*c(A), c(q)*c(A), -s(A), -s(A)*d],
                   [ s(q)*s(A), c(q)*s(A),  c(A),  c(A)*d],
                   [         0,         0,     0,       1],]).subs(subSyms)
    return Tsub

#=====================================================================================
# Kinematics 
#=====================================================================================

def kinematics():
    """
    Solve symbolically for the forward and inverse kinematics of the Kuka KR210 robotic
    arm.
    Returns symbolic equations for the end effector position (ee) from the Forward
    Kinematics (FK) section, the wrist center position (w) from the Inverse Kinematics
    (IK) section, and the joint angles (theta) from the IK section, as well as the
    transformation (T) and rotation (R) matrices used to develop them.
    """

    #-------------------------------------------------------------------------------------
    # Forward Kinematics 
    #-------------------------------------------------------------------------------------

    # Transforms Between Links
    #-------------------------------------------------------------------------------------
    T = {'0_1': Transform(A0, a0, d1, q1, dh),
         '1_2': Transform(A1, a1, d2, q2, dh),
         '2_3': Transform(A2, a2, d3, q3, dh),
         '3_4': Transform(A3, a3, d4, q4, dh),
         '4_5': Transform(A4, a4, d5, q5, dh),
         '5_6': Transform(A5, a5, d6, q6, dh),
         '6_7': Transform(A6, a6, d7, q7, dh),}
    
    # Composition of Homogeneous Transforms From Base_link to Link
    #-------------------------------------------------------------------------------------
    # The first transform relative to the base_link has been completed already,
    # now build the rest:
    for i in xrange(1, 7): # i = 1-->6
        #         T0_i+1 = T0_i * Ti_i+1
        T['0_'+str(i+1)] = T['0_'+str(i)] * T[str(i)+'_'+str(i+1)]

    # Transform for Gripper Link (7) From URDF to DH Convention
    #-------------------------------------------------------------------------------------
    # Intrinsic rotation about the Z-axis by 180 degrees and the Y-axis by -90 degrees.
    R = {'df2dh': R_z(pi) * R_y(-pi/2)} # NOTE: R['df2dh'] = R['df2dh'].T
    T['df2dh'] = R2T(R['df2dh'])

    # Total Corrected Homogeneous Transform Between Base_link and Gripper_link (7)
    #-------------------------------------------------------------------------------------
    T['0_G'] = T['0_7'] * T['df2dh']
    
    # End Effector Position
    #-------------------------------------------------------------------------------------
    ee = maybe_simplify( T['0_G'][:3, -1] )

    #-------------------------------------------------------------------------------------
    # Inverse Kinematics 
    #-------------------------------------------------------------------------------------
    
    # Get the Wrist Center Coordinates
    #-------------------------------------------------------------------------------------
    R['rpy'] = R_z(y) * R_y(p) * R_x(r) * R['df2dh']

    n    = R['rpy'][:,2] # extract the n vector along the z-axis of the gripper_link

    P    = Matrix([px, py, pz]) # ee position vector

    w    = maybe_simplify( P - (d6+d7) * n ).subs(dh) # vector to wrist center (wc)

    # Solve for Theta 1, 2, and 3
    #-------------------------------------------------------------------------------------
    theta = [None for _ in xrange(7)]       # list to store all symbolic theta equations
    wz2   = w[2] - d1                       # distance from joint2 to wc
    wr    = sqrt(w[0]**2 + w[1]**2)         # distance radially to wc
    wr2   = wr - a1                         # distance radially from join2 to wc
    A     = sqrt( d4**2 +  a3**2)           # distance from joint3 to wc
    B     = sqrt(wz2**2 + wr2**2)           # distance from joint2 to wc
    C     = a2                              # distance from joint2 to joint3
    a     = acos((-A**2+B**2+C**2)/(2*B*C)) # angle from link2 to B vector
    b     = acos((-B**2+A**2+C**2)/(2*A*C)) # angle from link2 to A vector
    aw    = atan2(wz2, wr2)                 # angle from joint2 to wc
    
    # The following theta 3 adjustment corrects the -0.54 m link4 sag.  The value of 0.036
    # observed in the walk-through video was used as a starting point, and then the
    # following value was converged upon by the bisection method until the overall end
    # effector offset in IK_debug.py was zero with a precision of nine (0.000000000).
    t3_adjust = 0.03598446

    theta[1]  = maybe_simplify(atan2(w[1], w[0])    ).subs(dh)
    theta[2]  = maybe_simplify(pi/2 - a - aw        ).subs(dh)
    theta[3]  = maybe_simplify(pi/2 - b - t3_adjust ).subs(dh)

    # Solve for Theta 4, 5, and 6
    #-------------------------------------------------------------------------------------
    R['0_3'] = getRfrom(T['0_3'])
    R['0_6'] = getRfrom(T['0_6'])

    #R['3_6'] = R['3_4'] * R['4_5'] * R['5_6']

    # For a rotation matrix, inverse = transpose.
    # R['3_6lhs'] =         (R['0_3'].inv(method="LU") * R['0_6'])
    # above is equal to (though the expressions may differ, they are equal):
    R['3_6lhs'] = maybe_simplify(R['0_3'].T * R['0_6'])
    R['3_6rhs'] = maybe_simplify(R['0_3'].T * R['rpy']) # all variables are known here
    
    # The theta equations below are derived from the printed results of R3_6lhs, and
    # by following the example in the "Euler Angles from a Rotation Matrix" section.
    rhs = R['3_6rhs']
    theta[4] = atan2(                       rhs[2,2], -rhs[0,2])
    theta[5] = atan2(sqrt(rhs[1,0]**2 + rhs[1,1]**2),  rhs[1,2])
    theta[6] = atan2(                      -rhs[1,1],  rhs[1,0])

    #-------------------------------------------------------------------------------------
    # Return symbolic equations for the ee vector, wrist center vector, and theta list,
    # as well as the transformation and rotation matrices used to develop them. 
    #-------------------------------------------------------------------------------------
    return ee, w, theta, T, R

def getLambdas(ee, w, theta):
    """
    Given symbolic equations for the end effector position (ee), the wrist center position
    (w), and the joint angles (theta), return lambda functions built with a numeric
    system, such as numpy, to calculate numerical values on the order of 100 times faster
    than sympy's evalf.
    
    References:
    http://docs.sympy.org/latest/modules/numeric-computation.html
    http://docs.sympy.org/latest/modules/utilities/lambdify.html
    """
    # NOTE: Using "numpy" as the lambda module and vectorizing the function input when
    # called is faster than using "math", but "math" can be faster if the function is
    # called serially in a loop due to numpy start-up time and overhead.  However, "math"
    # requires scalar equations, so the vector equations (ee and w) would need to be
    # separated into scalar equations to be compatible.  Higher performance options that
    # require less common dependencies are also available (see references above). 

    # Module with which to build the lambda functions
    module = 'numpy' #'mpmath'

    # Lambdify End Effector Position
    #-------------------------------------------------------------------------------------
    eval_ee = lambdify((q1,q2,q3,q4,q5,q6), ee, module)

    # Lambdify Wrist Center Position 
    #-------------------------------------------------------------------------------------
    eval_w  = lambdify((p,y,px,py,pz), w, module)

    # Lambdify Thetas
    #-------------------------------------------------------------------------------------
    eval_theta = [None for _ in theta] # list to store all of the lambdas to return

    # theta 1 --> 3
    for i in xrange(1,4):
        eval_theta[i] = lambdify(  (p,y,px,py,pz), theta[i], module)
    # theta 4 --> 6
    for i in xrange(4,7):
        eval_theta[i] = lambdify((r,p,y,q1,q2,q3), theta[i], module)

    # NOTE:
    # theta1 is not a function of pz, but it is included for function-calling convenience.
    # theta4 is not a function of r, but it is included for function-calling convenience.

    # Return Lambda Functions
    #-------------------------------------------------------------------------------------
    return eval_ee, eval_w, eval_theta
    
#=========================================================================================
# Miscellaneous Functions 
#=========================================================================================

def printEquations(ee, w, theta):
    print 'ee:\n', ee, '\n'
    print  'w:\n',  w, '\n'
    for i in xrange(1,len(theta)):
        print 'theta['+str(i)+']:\n', theta[i], '\n'

def in_pi(angle):
    """
    Convert angle (radians) to the range (-pi, pi].
    """
    angle %= 2*pi                #   0 <= a <  2*pi
    if angle > pi: angle -= 2*pi # -pi <  a <=   pi
    return a


##########################################################################################
# MAIN
##########################################################################################

#=========================================================================================
# Get Symbolic Equations
#=========================================================================================

#-----------------------------------------------------------------------------------------
# Read in ee, w, theta, T, and R From Pickle File 
#-----------------------------------------------------------------------------------------
if pickle_exists and not FORCE:
    try:
        with open(pickle_file, 'rb') as f:
            ee, w, theta, T, R = pickle.load(f)
    except Exception as e:
        print 'Unable to load ', pickle_file, ': ', e
        FORCE = True

#-----------------------------------------------------------------------------------------
# OR Calculate and Save to Pickle File 
#-----------------------------------------------------------------------------------------
if not pickle_exists or FORCE:
    ee, w, theta, T, R = kinematics()

    # Pickle ee, w, theta, T, and R
    #-------------------------------------------------------------------------------------
    try:
        with open(pickle_file, 'wb') as f:
            pickle.dump((ee, w, theta, T, R), f, pickle.HIGHEST_PROTOCOL)
    except Exception as e:
        print 'Unable to save to ', pickle_file, ': ', e

# Print Equations
#-----------------------------------------------------------------------------------------
if DEBUG: printEquations(ee, w, theta)

#=========================================================================================
# Get Lambda Functions for Evaluating EE Position, WC Position, and Thetas
#=========================================================================================

eval_ee, eval_w, eval_theta = getLambdas(ee, w, theta)


# END OF FILE ############################################################################
